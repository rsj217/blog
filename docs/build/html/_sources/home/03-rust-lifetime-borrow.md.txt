浅析 Rust 生存期 Lifetime -- 借用 borrow
========================================

Rust 是内存安全的语言，通过值的单一ownership机制，位置变量离开作用域的时候，可以自动析构其关联的值。不仅实现了自动化管理内存，还避免了悬垂引用和重复释放。Rust的Copy，Move语义提供了值的ownership操作相关的语义。

> 本文的约定，其他语言的 变量 ，在本文中使用 位置 这个名词。

Rust中不能在编译时确定大小的类型，需要存储在heap上。通过stack上的胖指针使用heap内存。函数调用的时候，每次都使用 move 语义，那么就需要返回的时候回收所有权。

```rust
fn main(){
    let s = "hello".to_string();
    let s = foo(s);
}

fn foo(s: String) -> String{
    s
}
```
如果使用 Clone 语义，虽然可以解决问题，但是会造成 heap 内存的复制。当 heap 上的数据很大的时候，会造成性能问题。一种常用的解决方法就是传引用。可以通过借用Borrow实现共享内存。即借用位置的值而不是转移所有权。

## 原始者与借用者

下面的代码中

```rust
fn main(){
    let v = "hello".to_string();
    let r1 = &v;
    let r2 = &v;
    
    let r3 = r1;
    
    let r4 = &r1;
}
```

v 是一个位置(变量)，它的值是一个指向heap的胖指针，heap上是指向静态区的"hello"字串。r1，r2 都是 v 的借用，r3 也是 r1 的胖指针copy，r4 是 r1 的借用。

为了描述方便，`let r4 = &r1;` 我们定义 r1 为原始者(source)，r4 为借用者(target)。

## 值存活期和生存期

位置是对值的绑定，每一个位置和其值都有其存活期。当位置离开其作用域，那么值和位置都会被释放。当值执行move语义之后，原始的值变成了 uninitialized，可以认为这个 位置 也就失效了，不能读也不能写。

rust 中的每一个借用类型，它们也和普通值一样有一个位置绑定，位置的存活期也是其作用域范围。但是每个借用除了存活期，还有生存期(Lifetime)。借用的lifetime指其声明绑定，到访问它的区间。

```rust
fn main() {
    let v = "hello".to_string();    //  ----------------+  v
                                    //                  |
    let r1 = &v;                    //  --------+ r1    |
                                    //          |       |
    println!("{}", r1);             //  --------+       |
                                    //  ----------------+
}
```

v 的存活期是其作用域，从 v 的定义到 main 函数花括号结束，r1的 lifetime 是其从其定义`let`语句到访问它的`println!`宏调用。多个借用之间，借用与原值之间的区间关系有两种，上述 v 的存活期完全覆盖 r1 的lifetime。下面的关系则是，两个借用 r1 和 r2 有交叉重叠。

```rust
fn main() {
    let v = "hello".to_string();    //  ----------------+  v
                                    //                  |
    let r1 = &v;                    //  --------+ r1    |
    let r2 = &v;                    //  ---+ r2    |    |
                                    //     |       |    |
                                    //     |       |    |
    println!("{}", r1);             //  ---+-------+    |
                                           |            |
    println!("{}", r2);             //  ---+            |
                                    //  ----------------+
}
```

交叉重叠的情况下，共享和独占的属性不一样，其结果页不一样。主要的原则大致是，可以有多个共享借用，但只能有一个独占借用，其目的就是独占借用可以修改原值，不符合预期的修改，会导致共享借用使用到非预期的值。当前的描述略抽象，下面针对rust借用中五个常见的case进行介绍。

## 借用规则

介绍了上面的约定之后，下面再来看 Rust 的借用规则。大致有 5 条规则。

### 借用的lifetime，不可超出其所有者的作用域

一个借用，其值是一个地址，这个地址要么是上一个借用的地址，要么就是原始值的地址。当前的借用的lifetime，不能超过它所依赖的变量的作用域。

```rust 
fn main() {

    let r: &i32;             //  ------------+ r
    {                        //              |
        let x = 10;          //  -----+ x    |
        r = &x;              //       |      |
            ^^ borrowed value does not live long enough
    }                        //  -----+      |
     - `x` dropped here while still borrowed
                             //              |
    println!("{}", r);       //  ------------+
                   - borrow later used here
}

```

上面的例子中，r的lifetime 覆盖了 x 的存活期，与第一条规则相悖。这是典型的悬垂引用，引用还存在，但是它所指向的值已被释放。

### 共享借用的lifetime内，所有者暂时不可变

共享借用的时候，所有者不能修改。这很好理解，引用使用了某个值，正要使用这个引用的时候，如果值变了，就会有意想不到的事情。

```rust
fn main() {
    let mut x = 100;                 //  -------------------------+ x
                                     //                           |
    x = 10;                          //                           |
    println!("{}", x);               //                           |
                                     //                           |
    let r1 = &x;        			 //  ------------+ r1         |
                                     //                           |
    x = 100;						 //                           |
                                     //                           |
    println!("{}", x);               //  -------------------------+
}
```
上述代码中，r1 并没有使用，其lifetime并不活跃。在其 r1 的 lifetime 内，x 并没有改变。因此是合法的，如果稍后访问一下 r1，是其lifetime撑开。则会变成非法：

```rust
fn main() {
    let mut x = 100;                 //  -------------------------+ x
                                     //                           |
    x = 10;                          //                           |
    println!("{}", x);               //                           |
                                     //                           |
    let r1 = &x;                     //  ------------+ r1         |
             -- borrow of `x` occurs here            |            |
    x = 100;                         //              |            |
    ^^^^^^^ assignment to borrowed `x` occurs here   |            |
    println!("{}", r1);              //  ------------+            |
                                     //                           |
    println!("{}", x);               //  -------------------------+
                   -- borrow later used here
}
```

```rust
fn main() {
    let mut x = 100;                 //  -------------------------+ x
                                     //                           |
    x = 10;                          //                           |
    println!("{}", x);               //                           |
                                     //                           |
    let r1 = &x;                     //  ------------+ r1         |
             -- immutable borrow occurs here         |            |
    let r2 = &mut x;                 //              |            |
             ^^^^^^ mutable borrow occurs here       |            |
    println!("{}", r1);              //  ------------+            |
                   -- immutable borrow later used here            |
    println!("{}", x);               //  -------------------------+
}
```

### 独占引用的原始值，必须是可变的

独占引用可以修改原始值，那么其借用的原始值必须声明为可变的。

```rust
fn main() {
    let x = 100;

    let r1 = &mut x;
             ^^^^^^ cannot borrow as mutable
}
```

将 x 声明为 可变的

```rust
fn main() {
    let mut x = 100;

    let r1 = &mut x;
    *r1 = 10;
    println!("{}", x);
}

```
通过 *r1 的取值修改，最终 x 的值被修改为 10。如果 x 没有 mut 修饰，那么使用 `*r1=10` 的时候就会逻辑不自恰，修改了一个不能修改的变量。

### 独占借用的lifetime内，所有者被冻结，不能读也不能写

与共享引用类似，在引用的lifetime内，原始值所有者也会有限制。其中对于独占引用，原始值所有者等价于被冻结。不能读写。

```rust
fn main() {
    let mut x = 100;                 //  -------------------------+ x
                                     //                           |
    x = 10;                          //                           |
    println!("{}", x);               //                           |
                                     //                           |
    let r1 = &mut x;                 //  ------------+ r1         |
                                     //                           |
    println!("{}", x);               //                           |
    x = 10;						     //                           |
                                     //                           |
    println!("{}", x);               //                           |
}                                    //  -------------------------+
```
r1 是独占引用，但是没有访问它，可以编译通过。

```rust
fn main() {
    let mut x = 100;                 //  -------------------------+ x
                                     //                           |
    x = 10;                          //                           |
    println!("{}", x);               //                           |
                                     //                           |
    let r1 = &mut x;                 //  -------------+ r1        |
             ------ mutable borrow occurs here        |           |
                                     //               |           |
    println!("{}", x);               //               |           |
                   ^ immutable borrow occurs here     |           |
                                     //               |           |
    println!("{}", r1);              //  -------------+           |
                   -- mutable borrow later used here              |
}                                    //  -------------------------+

```

当最后一行访问了 r1 ，r1的lifetime被撑开了，r1的lifetime内访问了 x，此时报错，x 被冻结，不能读写

```rust
fn main() {
    let mut x = 100;                 //  --------------------------+ x
                                     //                            |
    x = 10;                          //                            |
    println!("{}", x);               //                            |
                                     //                            |
    let r1 = &mut x;                 //  -------------+ r1 = 'a    |
                                     //               |            |
                                     //               |            |
    println!("{}", r1);              //  -------------+            |
                                     //                            |
    println!("{}", x);               //                            |
}                                    //  --------------------------+

```

上述的例子中，r1 的lifetime之后，x 恢复原样的属性，既可读也可写。


最后一种情况是引用与引用的关系，也是最复杂的一种。遇到类似的情况，只需要画出各引用的lifetime区间，再加以分析，就能拨云见雾，柳暗花明。


```rust
fn main() {
    let mut x = 100;                 //  --------------------------+ x
                                     //                            |
                                     //                            |
    let r1 = &mut x;                 //  -------------+ r1         |
             ------ mutable borrow occurs here        |            |
    let r2 = &x;                     //               |            |
             ^^ immutable borrow occurs here          |            |
    println!("{}", r1);              //  -------------+            |
                   -- mutable borrow later used here               |
}                                    //  --------------------------+

```

独占引用 r1 的lifetime 中，出现了 共享引用 r2，所有报错。

```rust
fn main() {
    let mut x = 100;                 //  --------------------------+ x
                                     //                            |
                                     //                            |
    let r1 = &mut x;                 //  -------------+ r1         |
                                     //               |            |
    let r2 = &r1;                    //  -------+ r2  |            |
                                     //         |     |            |
    println!("{}", r2);              //  -------+     |            |
                                     //               |            |
    println!("{}", r1);              //  -------------+            |
                                     //                            |
}                                    //  --------------------------+

```

尽管上面的 r1 的lifetime 覆盖了 r2，但是 r2 来源于 r1，这里的其他引用是指其他引用了 r1 所有者 x 的引用，这种覆盖是合法的。就类似所有者借出所有权之后，借出的变量使用完毕归还。同样的，下面尽管 r1 和 r2 lifetime 重叠，但是r1不是和其他引用的重叠

```rust
fn main() {
    let mut x = 100;                 //  --------------------------+ x
                                     //                            |
                                     //                            |
    let r1 = &mut x;                 //  -------------+ r1         |
                                     //               |            |
    let r2 = &r1;                    //  -------+ r2  |            |
                                     //         |     |            |
    println!("{}", r2);              //         |     |            |
                                     //         |     |            |
    println!("{}", r1);              //  -------+-----+            |
                                     //         |                  |
    println!("{}", r2);              //  -------+                  |
}                                    //  --------------------------+

```

```rust
fn main() {
    let mut x = 100;                 //  --------------------------+ x
                                     //                            |
                                     //                            |
    let r1 = &mut x;                 //  -------------+ r1         |
             --- borrow of `*r1` occurs here          |            |
    let r2 = &r1;                    //  -------+ r2  |            |
                                     //         |     |            |
    *r1 = 10;                        //         |     |            |
     ^^^^^^^^ assignment to borrowed `*r1` occurs here|            |
    println!("{}", r1);              //  -------+-----+            |
                                     //         |                  |
    println!("{}", r2);              //  -------+                  |
}                  -- borrow later used here ----------------------+

```
上面这种情况，可以看出是 在 r2 的lifetime内，其原始值 r1 不能变。与第一种case类似。移除最后一行对 r2 的访问，就能编译通过。














